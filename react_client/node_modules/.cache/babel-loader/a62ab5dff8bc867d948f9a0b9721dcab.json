{"ast":null,"code":"import axios from 'axios';\nexport const isTip = ({\n  links,\n  node\n}) => {\n  return !links.some(link => node === link.target);\n};\nexport const choose = arr => arr[Math.floor(Math.random() * arr.length)];\nexport const getDescendants = ({\n  nodes,\n  links,\n  root\n}) => {\n  const stack = [root];\n  const visitedNodes = new Set();\n  const visitedLinks = new Set();\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const outgoingEdges = links.filter(l => l.source === current);\n\n    for (let link of outgoingEdges) {\n      visitedLinks.add(link);\n\n      if (!visitedNodes.has(link.target)) {\n        stack.push(link.target);\n        visitedNodes.add(link.target);\n      }\n    }\n  }\n\n  return {\n    nodes: visitedNodes,\n    links: visitedLinks\n  };\n};\nexport const getAncestors = ({\n  nodes,\n  links,\n  root\n}) => {\n  const stack = [root];\n  const visitedNodes = new Set();\n  const visitedLinks = new Set();\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n    const incomingEdges = links.filter(l => l.target === current);\n\n    for (let link of incomingEdges) {\n      visitedLinks.add(link);\n\n      if (!visitedNodes.has(link.source)) {\n        stack.push(link.source);\n        visitedNodes.add(link.source);\n      }\n    }\n  }\n\n  return {\n    nodes: visitedNodes,\n    links: visitedLinks\n  };\n};\nexport const getTips = ({\n  nodes,\n  links\n}) => {\n  const tips = nodes.filter(node => !links.some(link => link.target === node));\n  return new Set(tips);\n};\nexport const getApprovers = ({\n  links,\n  node\n}) => {\n  return links.filter(link => link.target === node).map(link => link.source);\n};\nexport const randomWalk = ({\n  links,\n  start\n}) => {\n  let particle = start;\n\n  while (!isTip({\n    links,\n    node: particle\n  })) {\n    const approvers = getApprovers({\n      links,\n      node: particle\n    });\n    particle = choose(approvers);\n  }\n\n  return particle;\n};\n\nconst weightedChoose = (arr, weights) => {\n  const sum = weights.reduce((sum, w) => sum + w, 0);\n  const rand = Math.random() * sum;\n  let cumSum = weights[0];\n\n  for (let i = 1; i < arr.length; i++) {\n    if (rand < cumSum) {\n      return arr[i - 1];\n    }\n\n    cumSum += weights[i];\n  }\n\n  return arr[arr.length - 1];\n};\n\nexport const weightedRandomWalk = ({\n  nodes,\n  links,\n  start,\n  alpha\n}) => {\n  let particle = start;\n\n  while (!isTip({\n    links,\n    node: particle\n  })) {\n    const approvers = getApprovers({\n      links,\n      node: particle\n    });\n    const cumWeights = approvers.map(node => node.cumWeight); // normalize so maximum cumWeight is 0\n\n    const maxWeight = Math.max(...cumWeights);\n    const normalizedWeights = cumWeights.map(w => w - maxWeight);\n    const weights = normalizedWeights.map(w => Math.exp(alpha * w));\n    particle = weightedChoose(approvers, weights);\n  }\n\n  return particle;\n};\nexport const adaptiveMachineLearning = ({\n  nodes,\n  links,\n  start\n}) => {\n  let particle = start; // Let ML choose alpha value\n\n  let newAlpha = 0; // Get alpha value from python\n\n  axios.get('http://localhost:5000/alpha').then(res => {\n    newAlpha = res.data.alpha;\n    console.log(newAlpha);\n  });\n\n  while (!isTip({\n    links,\n    node: particle\n  })) {\n    const approvers = getApprovers({\n      links,\n      node: particle\n    });\n    const cumWeights = approvers.map(node => node.cumWeight); // normalize so maximum cumWeight is 0\n\n    const maxWeight = Math.max(...cumWeights);\n    const normalizedWeights = cumWeights.map(w => w - maxWeight);\n    const weights = normalizedWeights.map(w => Math.exp(newAlpha * w));\n    particle = weightedChoose(approvers, weights);\n  }\n\n  return particle;\n};\n\nconst getChildrenLists = ({\n  nodes,\n  links\n}) => {\n  // Initialize an empty list for each node\n  const childrenLists = nodes.reduce((lists, node) => Object.assign(lists, {\n    [node.name]: []\n  }), {});\n\n  for (let link of links) {\n    childrenLists[link.source.name].push(link.target);\n  }\n\n  return childrenLists;\n}; // DFS-based topological sort\n\n\nexport const topologicalSort = ({\n  nodes,\n  links\n}) => {\n  const childrenLists = getChildrenLists({\n    nodes,\n    links\n  });\n  const unvisited = new Set(nodes);\n  const result = [];\n\n  const visit = node => {\n    if (!unvisited.has(node)) {\n      return;\n    }\n\n    for (let child of childrenLists[node.name]) {\n      visit(child);\n    }\n\n    unvisited.delete(node);\n    result.push(node);\n  };\n\n  while (unvisited.size > 0) {\n    const node = unvisited.values().next().value;\n    visit(node);\n  }\n\n  result.reverse();\n  return result;\n};\nexport const calculateWeights = ({\n  nodes,\n  links\n}) => {\n  const sorted = topologicalSort({\n    nodes,\n    links\n  }); // Initialize an empty set for each node\n\n  const ancestorSets = nodes.reduce((lists, node) => Object.assign(lists, {\n    [node.name]: new Set()\n  }), {});\n  const childrenLists = getChildrenLists({\n    nodes,\n    links\n  });\n\n  for (let node of sorted) {\n    for (let child of childrenLists[node.name]) {\n      ancestorSets[child.name] = new Set([...ancestorSets[child.name], ...ancestorSets[node.name], node]);\n    }\n\n    node.cumWeight = ancestorSets[node.name].size + 1;\n  }\n};","map":{"version":3,"sources":["/home/crawlins/IdeaProjects/IOTAVis/react_client/src/shared/algorithms.js"],"names":["axios","isTip","links","node","some","link","target","choose","arr","Math","floor","random","length","getDescendants","nodes","root","stack","visitedNodes","Set","visitedLinks","current","pop","outgoingEdges","filter","l","source","add","has","push","getAncestors","incomingEdges","getTips","tips","getApprovers","map","randomWalk","start","particle","approvers","weightedChoose","weights","sum","reduce","w","rand","cumSum","i","weightedRandomWalk","alpha","cumWeights","cumWeight","maxWeight","max","normalizedWeights","exp","adaptiveMachineLearning","newAlpha","get","then","res","data","console","log","getChildrenLists","childrenLists","lists","Object","assign","name","topologicalSort","unvisited","result","visit","child","delete","size","values","next","value","reverse","calculateWeights","sorted","ancestorSets"],"mappings":"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","sourcesContent":["import axios from 'axios';\n\nexport const isTip = ({links, node}) => {\n  return !links.some(link => node === link.target);\n};\n\nexport const choose = arr => arr[Math.floor(Math.random() * arr.length)];\n\nexport const getDescendants = ({nodes, links, root}) => {\n  const stack = [root];\n  const visitedNodes = new Set();\n  const visitedLinks = new Set();\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n\n    const outgoingEdges = links.filter(l => l.source === current);\n    for (let link of outgoingEdges) {\n      visitedLinks.add(link);\n      if (!visitedNodes.has(link.target)) {\n        stack.push(link.target);\n        visitedNodes.add(link.target);\n      }\n    }\n  }\n\n  return {nodes: visitedNodes, links: visitedLinks};\n};\n\nexport const getAncestors = ({nodes, links, root}) => {\n  const stack = [root];\n  const visitedNodes = new Set();\n  const visitedLinks = new Set();\n\n  while (stack.length > 0) {\n    const current = stack.pop();\n\n    const incomingEdges = links.filter(l => l.target === current);\n    for (let link of incomingEdges) {\n      visitedLinks.add(link);\n      if (!visitedNodes.has(link.source)) {\n        stack.push(link.source);\n        visitedNodes.add(link.source);\n      }\n    }\n  }\n\n  return {nodes: visitedNodes, links: visitedLinks};\n};\n\nexport const getTips = ({nodes, links}) => {\n  const tips = nodes.filter(node =>\n    !links.some(link => link.target === node));\n\n  return new Set(tips);\n};\n\nexport const getApprovers = ({links, node}) => {\n  return links\n    .filter(link => link.target === node)\n    .map(link => link.source);\n};\n\nexport const randomWalk = ({links, start}) => {\n  let particle = start;\n\n  while (!isTip({links, node: particle})) {\n    const approvers = getApprovers({links, node: particle});\n\n    particle = choose(approvers);\n  }\n\n  return particle;\n};\n\nconst weightedChoose = (arr, weights) => {\n  const sum = weights.reduce((sum, w) => sum + w, 0);\n  const rand = Math.random() * sum;\n\n  let cumSum = weights[0];\n  for (let i=1; i < arr.length; i++) {\n    if (rand < cumSum) {\n      return arr[i-1];\n    }\n    cumSum += weights[i];\n  }\n\n  return arr[arr.length-1];\n};\n\nexport const weightedRandomWalk = ({nodes, links, start, alpha}) => {\n  let particle = start;\n\n  while (!isTip({links, node: particle})) {\n    const approvers = getApprovers({links, node: particle});\n\n    const cumWeights = approvers.map(node => node.cumWeight);\n\n    // normalize so maximum cumWeight is 0\n    const maxWeight = Math.max(...cumWeights);\n    const normalizedWeights = cumWeights.map(w => w - maxWeight);\n\n    const weights = normalizedWeights.map(w => Math.exp(alpha * w));\n\n    particle = weightedChoose(approvers, weights);\n  }\n\n  return particle;\n};\n\nexport const adaptiveMachineLearning = ({nodes, links, start}) =>{\n  let particle = start;\n\n  // Let ML choose alpha value\n  let newAlpha = 0;\n\n  // Get alpha value from python\n  axios.get('http://localhost:5000/alpha')\n      .then(res =>{\n        newAlpha = res.data.alpha;\n        console.log(newAlpha);\n      });\n\n  while (!isTip({links, node: particle})) {\n    const approvers = getApprovers({links, node: particle});\n    const cumWeights = approvers.map(node => node.cumWeight);\n\n    // normalize so maximum cumWeight is 0\n    const maxWeight = Math.max(...cumWeights);\n    const normalizedWeights = cumWeights.map(w => w - maxWeight);\n\n    const weights = normalizedWeights.map(w => Math.exp( newAlpha* w));\n\n    particle = weightedChoose(approvers, weights);\n  }\n\n  return particle;\n\n};\n\nconst getChildrenLists = ({nodes, links}) => {\n  // Initialize an empty list for each node\n  const childrenLists = nodes.reduce((lists, node) =>\n    Object.assign(lists, {[node.name]: []}), {});\n\n  for (let link of links) {\n    childrenLists[link.source.name].push(link.target);\n  }\n\n  return childrenLists;\n};\n\n// DFS-based topological sort\nexport const topologicalSort = ({nodes, links}) => {\n  const childrenLists = getChildrenLists({nodes, links});\n  const unvisited = new Set(nodes);\n  const result = [];\n\n  const visit = node => {\n    if (!unvisited.has(node)) {\n      return;\n    }\n\n    for (let child of childrenLists[node.name]) {\n      visit(child);\n    }\n\n    unvisited.delete(node);\n    result.push(node);\n  };\n\n  while (unvisited.size > 0) {\n    const node = unvisited.values().next().value;\n\n    visit(node);\n  }\n\n  result.reverse();\n  return result;\n};\n\nexport const calculateWeights = ({nodes, links}) => {\n  const sorted = topologicalSort({nodes, links});\n\n  // Initialize an empty set for each node\n  const ancestorSets = nodes.reduce((lists, node) =>\n    Object.assign(lists, {[node.name]: new Set()}), {});\n\n  const childrenLists = getChildrenLists({nodes, links});\n  for (let node of sorted) {\n    for (let child of childrenLists[node.name]) {\n      ancestorSets[child.name] = new Set([...ancestorSets[child.name], ...ancestorSets[node.name], node]);\n    }\n\n    node.cumWeight = ancestorSets[node.name].size + 1;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}